import fs from 'fs';
import path from 'path';

/**
 * Ensures the uploads directory exists
 */
export function ensureUploadsDirectory(): string {
  const uploadsDir = path.join(process.cwd(), 'public', 'uploads');
  
  // Create directory if it doesn't exist
  if (!fs.existsSync(uploadsDir)) {
    fs.mkdirSync(uploadsDir, { recursive: true });
  }
  
  return uploadsDir;
}

/**
 * Gets a formatted file size string
 */
export function formatFileSize(bytes: number): string {
  if (bytes < 1024) {
    return `${bytes} B`;
  } else if (bytes < 1024 * 1024) {
    return `${(bytes / 1024).toFixed(2)} KB`;
  } else if (bytes < 1024 * 1024 * 1024) {
    return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
  } else {
    return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
  }
}

/**
 * Validate file type
 */
export function validateFileType(file: File, acceptedTypes: string[] = ['audio/mpeg', 'audio/wav', 'audio/mp3']): boolean {
  return acceptedTypes.includes(file.type);
}

/**
 * Get file extension from mime type
 */
export function getExtensionFromMimeType(mimeType: string): string {
  const mimeToExt: Record<string, string> = {
    // Audio
    'audio/mpeg': 'mp3',
    'audio/mp3': 'mp3',
    'audio/wav': 'wav',
    'audio/x-wav': 'wav',
    'audio/flac': 'flac',
    'audio/ogg': 'ogg',
    
    // Images
    'image/jpeg': 'jpg',
    'image/jpg': 'jpg',
    'image/png': 'png',
    'image/webp': 'webp',
    'image/gif': 'gif'
  };
  
  // If mime type is unknown, try to guess from file extension
  return mimeToExt[mimeType] || 'bin';
}

/**
 * Get common image formats
 */
export function getAcceptedImageTypes(): string[] {
  return ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
}

/**
 * Get common audio formats
 */
export function getAcceptedAudioTypes(): string[] {
  return ['audio/mpeg', 'audio/wav', 'audio/mp3', 'audio/x-wav'];
}

/**
 * Creates a folder name that includes the track title and ID
 * @param trackTitle The title of the track
 * @param trackId The unique ID of the track
 * @param artistName Optional artist name
 * @param releaseDate Optional release date
 * @returns A sanitized folder name
 */
export function getTrackFolderName(
  trackTitle: string, 
  trackId: string, 
  artistName?: string, 
  releaseDate?: string
): string {
  // Ensure we have a title, use "untitled" if none provided
  const title = trackTitle ? trackTitle.trim() : 'untitled';
  
  // Sanitize the title for safe use in filenames/paths
  const sanitizedTitle = title
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // Remove special characters except spaces, hyphens, and underscores
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .substring(0, 50); // Limit length to prevent very long folder names
  
  // Always include the ID to ensure uniqueness
  let folderName = `${sanitizedTitle}_${trackId.substring(0, 8)}`;
  
  // Add artist info if provided
  if (artistName) {
    const sanitizedArtist = artistName
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .substring(0, 30);
    
    folderName = `${sanitizedTitle}_by_${sanitizedArtist}_${trackId.substring(0, 8)}`;
  }
  
  return folderName;
}

/**
 * Generates an S3 key for a file
 * @param folderName The folder name generated by getTrackFolderName
 * @param fileType The type of file (main, stem, image)
 * @param filename The filename
 * @returns The full S3 key
 */
export function getS3Key(folderName: string, fileType: string, filename: string): string {
  if (fileType === 'image') {
    return `tracks/${folderName}/${filename}`;
  } else if (fileType === 'stem') {
    return `tracks/${folderName}/stems/${filename}`;
  } else {
    // Main track file
    return `tracks/${folderName}/${filename}`;
  }
} 